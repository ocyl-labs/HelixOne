# .github/workflows/deploy-production.yml
name: Deploy to Production

on:
  push:
    branches: [ main ]
    tags: [ 'v*' ]
  pull_request:
    branches: [ main ]

env:
  AWS_REGION: us-west-2
  ECR_REGISTRY: ${{ secrets.AWS_ACCOUNT_ID }}.dkr.ecr.us-west-2.amazonaws.com
  EKS_CLUSTER_NAME: helixone-production

jobs:
  test:
    name: Run Tests
    runs-on: ubuntu-latest
    services:
      postgres:
        image: postgres:15
        env:
          POSTGRES_PASSWORD: postgres
          POSTGRES_DB: helixone_test
        options: >-
          --health-cmd pg_isready
          --health-interval 10s
          --health-timeout 5s
          --health-retries 5
      redis:
        image: redis:7-alpine
        options: >-
          --health-cmd "redis-cli ping"
          --health-interval 10s
          --health-timeout 5s
          --health-retries 5

    steps:
    - name: Checkout code
      uses: actions/checkout@v4

    - name: Set up Python
      uses: actions/setup-python@v4
      with:
        python-version: '3.11'

    - name: Cache dependencies
      uses: actions/cache@v3
      with:
        path: ~/.cache/pip
        key: ${{ runner.os }}-pip-${{ hashFiles('**/requirements.txt') }}
        restore-keys: |
          ${{ runner.os }}-pip-

    - name: Install dependencies
      run: |
        python -m pip install --upgrade pip
        pip install -r requirements.txt
        pip install pytest pytest-asyncio pytest-cov

    - name: Run linting
      run: |
        pip install black flake8 isort
        black --check .
        flake8 .
        isort --check-only .

    - name: Run security scan
      run: |
        pip install bandit safety
        bandit -r . -x tests/
        safety check

    - name: Run unit tests
      env:
        DATABASE_URL: postgresql://postgres:postgres@localhost:5432/helixone_test
        REDIS_URL: redis://localhost:6379
        JWT_SECRET: test-jwt-secret-key-for-testing-only
      run: |
        pytest --cov=. --cov-report=xml --cov-report=html

    - name: Upload coverage reports
      uses: codecov/codecov-action@v3
      with:
        file: ./coverage.xml
        flags: unittests
        name: codecov-umbrella

  security-scan:
    name: Security Scan
    runs-on: ubuntu-latest
    steps:
    - name: Checkout code
      uses: actions/checkout@v4

    - name: Run Trivy vulnerability scanner
      uses: aquasecurity/trivy-action@master
      with:
        scan-type: 'fs'
        scan-ref: '.'
        format: 'sarif'
        output: 'trivy-results.sarif'

    - name: Upload Trivy scan results to GitHub Security tab
      uses: github/codeql-action/upload-sarif@v2
      with:
        sarif_file: 'trivy-results.sarif'

  build:
    name: Build and Push Images
    runs-on: ubuntu-latest
    needs: [test, security-scan]
    if: github.event_name == 'push' && (github.ref == 'refs/heads/main' || startsWith(github.ref, 'refs/tags/'))
    
    strategy:
      matrix:
        service: [api, frontend, data-service]

    steps:
    - name: Checkout code
      uses: actions/checkout@v4

    - name: Configure AWS credentials
      uses: aws-actions/configure-aws-credentials@v4
      with:
        aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
        aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
        aws-region: ${{ env.AWS_REGION }}

    - name: Login to Amazon ECR
      id: login-ecr
      uses: aws-actions/amazon-ecr-login@v2

    - name: Extract metadata
      id: meta
      uses: docker/metadata-action@v5
      with:
        images: ${{ env.ECR_REGISTRY }}/helixone/${{ matrix.service }}
        tags: |
          type=ref,event=branch
          type=ref,event=pr
          type=semver,pattern={{version}}
          type=semver,pattern={{major}}.{{minor}}
          type=sha,prefix={{branch}}-

    - name: Set up Docker Buildx
      uses: docker/setup-buildx-action@v3

    - name: Build and push Docker image
      uses: docker/build-push-action@v5
      with:
        context: .
        file: ./docker/${{ matrix.service }}/Dockerfile
        push: true
        tags: ${{ steps.meta.outputs.tags }}
        labels: ${{ steps.meta.outputs.labels }}
        cache-from: type=gha
        cache-to: type=gha,mode=max
        platforms: linux/amd64

    - name: Scan image with Trivy
      uses: aquasecurity/trivy-action@master
      with:
        image-ref: ${{ env.ECR_REGISTRY }}/helixone/${{ matrix.service }}:${{ github.sha }}
        format: 'sarif'
        output: 'trivy-image-results.sarif'

    - name: Upload Trivy image scan results
      uses: github/codeql-action/upload-sarif@v2
      with:
        sarif_file: 'trivy-image-results.sarif'

  deploy:
    name: Deploy to Production
    runs-on: ubuntu-latest
    needs: build
    if: github.event_name == 'push' && github.ref == 'refs/heads/main'
    environment:
      name: production
      url: https://helixone.com

    steps:
    - name: Checkout code
      uses: actions/checkout@v4

    - name: Configure AWS credentials
      uses: aws-actions/configure-aws-credentials@v4
      with:
        aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
        aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
        aws-region: ${{ env.AWS_REGION }}

    - name: Update kubeconfig
      run: |
        aws eks update-kubeconfig --region ${{ env.AWS_REGION }} --name ${{ env.EKS_CLUSTER_NAME }}

    - name: Install kubectl
      uses: azure/setup-kubectl@v3
      with:
        version: 'v1.28.0'

    - name: Install Helm
      uses: azure/setup-helm@v3
      with:
        version: '3.12.0'

    - name: Deploy to EKS
      run: |
        # Replace image tags in Kubernetes manifests
        export IMAGE_TAG=${{ github.sha }}
        export ECR_REGISTRY=${{ env.ECR_REGISTRY }}
        
        # Update API deployment
        envsubst < kubernetes/api-deployment.yaml | kubectl apply -f -
        
        # Update frontend deployment
        envsubst < kubernetes/frontend-deployment.yaml | kubectl apply -f -
        
        # Update data service deployment
        envsubst < kubernetes/data-service-deployment.yaml | kubectl apply -f -
        
        # Wait for rollout to complete
        kubectl rollout status deployment/helixone-api -n helixone --timeout=600s
        kubectl rollout status deployment/helixone-frontend -n helixone --timeout=600s
        kubectl rollout status deployment/helixone-data-service -n helixone --timeout=600s

    - name: Run database migrations
      run: |
        kubectl run migration-job-${{ github.sha }} \
          --image=${{ env.ECR_REGISTRY }}/helixone/api:${{ github.sha }} \
          --restart=Never \
          --env="DATABASE_URL=${{ secrets.DATABASE_URL }}" \
          --command -- python -m alembic upgrade head
        
        # Wait for migration to complete
        kubectl wait --for=condition=complete job/migration-job-${{ github.sha }} --timeout=300s
        
        # Cleanup migration job
        kubectl delete job migration-job-${{ github.sha }}

    - name: Smoke tests
      run: |
        # Wait for services to be ready
        sleep 30
        
        # Test API health endpoint
        kubectl run smoke-test-${{ github.sha }} \
          --image=curlimages/curl:8.1.0 \
          --restart=Never \
          --command -- curl -f http://helixone-api-service:8000/health
        
        # Test frontend health
        kubectl run frontend-test-${{ github.sha }} \
          --image=curlimages/curl:8.1.0 \
          --restart=Never \
          --command -- curl -f http://helixone-frontend-service:3000/health
        
        # Cleanup test pods
        kubectl delete pod smoke-test-${{ github.sha }} --ignore-not-found
        kubectl delete pod frontend-test-${{ github.sha }} --ignore-not-found

    - name: Notify deployment
      uses: 8398a7/action-slack@v3
      with:
        status: ${{ job.status }}
        channel: '#deployments'
        text: |
          HelixOne Production Deployment
          Status: ${{ job.status }}
          Commit: ${{ github.sha }}
          Author: ${{ github.actor }}
          URL: https://helixone.com
      env:
        SLACK_WEBHOOK_URL: ${{ secrets.SLACK_WEBHOOK_URL }}

# =============================================================================
# DOCKERFILE CONFIGURATIONS
# =============================================================================

---
# docker/api/Dockerfile
FROM python:3.11-slim as builder

WORKDIR /app

# Install system dependencies
RUN apt-get update && apt-get install -y \
    gcc \
    libpq-dev \
    && rm -rf /var/lib/apt/lists/*

# Copy requirements and install Python dependencies
COPY requirements.txt .
RUN pip install --no-cache-dir --user -r requirements.txt

# Production stage
FROM python:3.11-slim

WORKDIR /app

# Install runtime dependencies
RUN apt-get update && apt-get install -y \
    libpq5 \
    && rm -rf /var/lib/apt/lists/* \
    && groupadd -r helixone && useradd -r -g helixone helixone

# Copy installed packages from builder
COPY --from=builder /root/.local /home/helixone/.local

# Copy application code
COPY . .

# Set ownership and permissions
RUN chown -R helixone:helixone /app

# Switch to non-root user
USER helixone

# Add local packages to PATH
ENV PATH=/home/helixone/.local/bin:$PATH

# Health check
HEALTHCHECK --interval=30s --timeout=30s --start-period=5s --retries=3 \
  CMD curl -f http://localhost:8000/health || exit 1

EXPOSE 8000

CMD ["python", "-m", "uvicorn", "sprint_1_backend_api:app", "--host", "0.0.0.0", "--port", "8000", "--workers", "4"]

---
# docker/frontend/Dockerfile
# Build stage
FROM node:18-alpine as builder

WORKDIR /app

# Copy package files
COPY frontend/package*.json ./

# Install dependencies
RUN npm ci --only=production

# Copy source code
COPY frontend/ .

# Build application
RUN npm run build

# Production stage
FROM nginx:alpine

# Copy built application
COPY --from=builder /app/build /usr/share/nginx/html

# Copy nginx configuration
COPY docker/frontend/nginx.conf /etc/nginx/nginx.conf

# Create non-root user
RUN addgroup -g 1001 -S helixone && adduser -S helixone -u 1001

# Set permissions
RUN chown -R helixone:helixone /usr/share/nginx/html && \
    chown -R helixone:helixone /var/cache/nginx && \
    chown -R helixone:helixone /var/log/nginx && \
    chown -R helixone:helixone /etc/nginx/conf.d

RUN touch /var/run/nginx.pid && \
    chown -R helixone:helixone /var/run/nginx.pid

# Switch to non-root user
USER helixone

# Health check
HEALTHCHECK --interval=30s --timeout=30s --start-period=5s --retries=3 \
  CMD wget --no-verbose --tries=1 --spider http://localhost:3000/health || exit 1

EXPOSE 3000

CMD ["nginx", "-g", "daemon off;"]

---
# docker/frontend/nginx.conf
worker_processes auto;
error_log /var/log/nginx/error.log warn;
pid /var/run/nginx.pid;

events {
    worker_connections 1024;
    use epoll;
}

http {
    include /etc/nginx/mime.types;
    default_type application/octet-stream;

    log_format main '$remote_addr - $remote_user [$time_local] "$request" '
                    '$status $body_bytes_sent "$http_referer" '
                    '"$http_user_agent" "$http_x_forwarded_for"';

    access_log /var/log/nginx/access.log main;

    sendfile on;
    tcp_nopush on;
    tcp_nodelay on;
    keepalive_timeout 65;
    types_hash_max_size 2048;

    # Gzip compression
    gzip on;
    gzip_vary on;
    gzip_min_length 1024;
    gzip_types text/plain text/css text/xml text/javascript application/javascript application/xml+rss application/json;

    # Security headers
    add_header X-Frame-Options "SAMEORIGIN" always;
    add_header X-XSS-Protection "1; mode=block" always;
    add_header X-Content-Type-Options "nosniff" always;
    add_header Referrer-Policy "no-referrer-when-downgrade" always;
    add_header Content-Security-Policy "default-src 'self' http: https: data: blob: 'unsafe-inline'" always;

    server {
        listen 3000;
        server_name localhost;
        root /usr/share/nginx/html;
        index index.html index.htm;

        # Health check endpoint
        location /health {
            access_log off;
            return 200 "healthy\n";
            add_header Content-Type text/plain;
        }

        # Handle client-side routing
        location / {
            try_files $uri $uri/ /index.html;
        }

        # Cache static assets
        location ~* \.(js|css|png|jpg|jpeg|gif|ico|svg)$ {
            expires 1y;
            add_header Cache-Control "public, immutable";
        }

        # Security headers for HTML files
        location ~* \.html$ {
            expires -1;
            add_header Cache-Control "no-store, no-cache, must-revalidate";
        }
    }
}

---
# docker/data-service/Dockerfile
FROM python:3.11-slim as builder

WORKDIR /app

# Install system dependencies
RUN apt-get update && apt-get install -y \
    gcc \
    libpq-dev \
    && rm -rf /var/lib/apt/lists/*

# Copy requirements and install Python dependencies
COPY requirements.txt .
RUN pip install --no-cache-dir --user -r requirements.txt

# Production stage
FROM python:3.11-slim

WORKDIR /app

# Install runtime dependencies
RUN apt-get update && apt-get install -y \
    libpq5 \
    && rm -rf /var/lib/apt/lists/* \
    && groupadd -r helixone && useradd -r -g helixone helixone

# Copy installed packages from builder
COPY --from=builder /root/.local /home/helixone/.local

# Copy application code
COPY . .

# Set ownership and permissions
RUN chown -R helixone:helixone /app

# Switch to non-root user
USER helixone

# Add local packages to PATH
ENV PATH=/home/helixone/.local/bin:$PATH

EXPOSE 8001

CMD ["python", "sprint_2_live_data.py"]

# =============================================================================
# MONITORING AND OBSERVABILITY
# =============================================================================

---
# monitoring/prometheus-values.yaml
prometheus:
  prometheusSpec:
    retention: 30d
    storageSpec:
      volumeClaimTemplate:
        spec:
          storageClassName: gp3
          accessModes: ["ReadWriteOnce"]
          resources:
            requests:
              storage: 100Gi
    
    additionalScrapeConfigs:
    - job_name: 'helixone-api'
      kubernetes_sd_configs:
      - role: endpoints
        namespaces:
          names:
          - helixone
      relabel_configs:
      - source_labels: [__meta_kubernetes_service_name]
        action: keep
        regex: helixone-api-service

grafana:
  adminPassword: ${GRAFANA_ADMIN_PASSWORD}
  persistence:
    enabled: true
    storageClassName: gp3
    size: 10Gi
  
  dashboardProviders:
    dashboardproviders.yaml:
      apiVersion: 1
      providers:
      - name: 'helixone'
        orgId: 1
        folder: 'HelixOne'
        type: file
        disableDeletion: false
        editable: true
        options:
          path: /var/lib/grafana/dashboards/helixone

  dashboards:
    helixone:
      api-metrics:
        gnetId: 14316
        revision: 1
        datasource: Prometheus

alertmanager:
  config:
    global:
      slack_api_url: '${SLACK_WEBHOOK_URL}'
    
    route:
      group_by: ['alertname']
      group_wait: 10s
      group_interval: 10s
      repeat_interval: 1h
      receiver: 'slack-notifications'
    
    receivers:
    - name: 'slack-notifications'
      slack_configs:
      - channel: '#alerts'
        title: 'HelixOne Alert'
        text: '{{ range .Alerts }}{{ .Annotations.summary }}{{ end }}'

---
# monitoring/helixone-servicemonitor.yaml
apiVersion: monitoring.coreos.com/v1
kind: ServiceMonitor
metadata:
  name: helixone-api-metrics
  namespace: helixone
  labels:
    app: helixone-api
spec:
  selector:
    matchLabels:
      app: helixone-api
  endpoints:
  - port: http
    interval: 30s
    path: /metrics

---
# monitoring/alerts.yaml
apiVersion: monitoring.coreos.com/v1
kind: PrometheusRule
metadata:
  name: helixone-alerts
  namespace: helixone
  labels:
    app: helixone
spec:
  groups:
  - name: helixone.rules
    rules:
    - alert: HelixOneAPIDown
      expr: up{job="helixone-api"} == 0
      for: 1m
      labels:
        severity: critical
      annotations:
        summary: "HelixOne API is down"
        description: "HelixOne API has been down for more than 1 minute."

    - alert: HelixOneHighErrorRate
      expr: rate(http_requests_total{status=~"5.."}[5m]) > 0.1
      for: 5m
      labels:
        severity: warning
      annotations:
        summary: "High error rate in HelixOne API"
        description: "Error rate is above 10% for the last 5 minutes."

    - alert: HelixOneHighLatency
      expr: histogram_quantile(0.95, rate(http_request_duration_seconds_bucket[5m])) > 2
      for: 5m
      labels:
        severity: warning
      annotations:
        summary: "High latency in HelixOne API"
        description: "95th percentile latency is above 2 seconds."

    - alert: HelixOneDatabaseConnections
      expr: postgres_stat_database_numbackends > 80
      for: 5m
      labels:
        severity: warning
      annotations:
        summary: "High database connections"
        description: "Database connection count is above 80."

    - alert: HelixOneRedisMemoryUsage
      expr: redis_memory_used_bytes / redis_memory_max_bytes > 0.8
      for: 5m
      labels:
        severity: warning
      annotations:
        summary: "High Redis memory usage"
        description: "Redis memory usage is above 80%."

---
# monitoring/loki-values.yaml
loki:
  config:
    schema_config:
      configs:
        - from: 2020-10-24
          store: boltdb-shipper
          object_store: s3
          schema: v11
          index:
            prefix: loki_
            period: 24h
    
    storage_config:
      boltdb_shipper:
        active_index_directory: /loki/boltdb-shipper-active
        cache_location: /loki/boltdb-shipper-cache
        shared_store: s3
      aws:
        s3: s3://${LOKI_S3_BUCKET}/loki
        region: ${AWS_REGION}

  persistence:
    enabled: true
    storageClassName: gp3
    size: 20Gi

promtail:
  config:
    clients:
    - url: http://loki:3100/loki/api/v1/push

# =============================================================================
# DEPLOYMENT SCRIPTS
# =============================================================================

---
# scripts/deploy.sh
#!/bin/bash
set -euo pipefail

# HelixOne Production Deployment Script
# Usage: ./scripts/deploy.sh [environment]

ENVIRONMENT=${1:-production}
SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
PROJECT_ROOT="$(dirname "$SCRIPT_DIR")"

echo "üöÄ Deploying HelixOne to $ENVIRONMENT environment"

# Check prerequisites
command -v aws >/dev/null 2>&1 || { echo "AWS CLI is required but not installed. Aborting." >&2; exit 1; }
command -v kubectl >/dev/null 2>&1 || { echo "kubectl is required but not installed. Aborting." >&2; exit 1; }
command -v helm >/dev/null 2>&1 || { echo "Helm is required but not installed. Aborting." >&2; exit 1; }
command -v terraform >/dev/null 2>&1 || { echo "Terraform is required but not installed. Aborting." >&2; exit 1; }

# Load environment variables
if [ -f "$PROJECT_ROOT/.env.$ENVIRONMENT" ]; then
    echo "üìã Loading environment variables from .env.$ENVIRONMENT"
    set -o allexport
    source "$PROJECT_ROOT/.env.$ENVIRONMENT"
    set +o allexport
else
    echo "‚ö†Ô∏è  No environment file found at .env.$ENVIRONMENT"
fi

# Configure AWS CLI
echo "üîß Configuring AWS CLI"
aws sts get-caller-identity > /dev/null || {
    echo "‚ùå AWS credentials not configured. Please run 'aws configure'"
    exit 1
}

# Update kubeconfig
echo "üîß Updating kubeconfig for EKS cluster"
aws eks update-kubeconfig --region "${AWS_REGION:-us-west-2}" --name "helixone-$ENVIRONMENT"

# Deploy infrastructure with Terraform
echo "üèóÔ∏è  Deploying infrastructure with Terraform"
cd "$PROJECT_ROOT/terraform"
terraform init
terraform plan -var-file="$ENVIRONMENT.tfvars"
read -p "Do you want to apply these changes? (y/N): " -n 1 -r
echo
if [[ $REPLY =~ ^[Yy]$ ]]; then
    terraform apply -var-file="$ENVIRONMENT.tfvars" -auto-approve
else
    echo "‚ùå Terraform deployment cancelled"
    exit 1
fi

# Get ECR registry URL
ECR_REGISTRY=$(aws sts get-caller-identity --query Account --output text).dkr.ecr.${AWS_REGION:-us-west-2}.amazonaws.com

# Build and push Docker images
echo "üê≥ Building and pushing Docker images"
aws ecr get-login-password --region "${AWS_REGION:-us-west-2}" | docker login --username AWS --password-stdin "$ECR_REGISTRY"

services=("api" "frontend" "data-service")
for service in "${services[@]}"; do
    echo "Building $service image..."
    docker build -f "docker/$service/Dockerfile" -t "helixone/$service:latest" .
    docker tag "helixone/$service:latest" "$ECR_REGISTRY/helixone/$service:latest"
    docker push "$ECR_REGISTRY/helixone/$service:latest"
done

# Install/upgrade monitoring stack
echo "üìä Installing monitoring stack"
kubectl create namespace monitoring --dry-run=client -o yaml | kubectl apply -f -

helm repo add prometheus-community https://prometheus-community.github.io/helm-charts
helm repo add grafana https://grafana.github.io/helm-charts
helm repo update

helm upgrade --install prometheus-stack prometheus-community/kube-prometheus-stack \
    --namespace monitoring \
    --values monitoring/prometheus-values.yaml \
    --wait

helm upgrade --install loki grafana/loki-stack \
    --namespace monitoring \
    --values monitoring/loki-values.yaml \
    --wait

# Deploy application
echo "üöÄ Deploying HelixOne application"
kubectl create namespace helixone --dry-run=client -o yaml | kubectl apply -f -

# Install External Secrets Operator
kubectl create namespace external-secrets-system --dry-run=client -o yaml | kubectl apply -f -
helm repo add external-secrets https://charts.external-secrets.io
helm upgrade --install external-secrets external-secrets/external-secrets \
    --namespace external-secrets-system \
    --wait

# Apply Kubernetes manifests
export ECR_REGISTRY
export IMAGE_TAG=latest
export API_SERVICE_ROLE_ARN=$(terraform output -raw api_service_role_arn)

for manifest in kubernetes/*.yaml; do
    echo "Applying $manifest..."
    envsubst < "$manifest" | kubectl apply -f -
done

# Wait for deployments
echo "‚è≥ Waiting for deployments to be ready"
kubectl rollout status deployment/helixone-api -n helixone --timeout=600s
kubectl rollout status deployment/helixone-frontend -n helixone --timeout=600s
kubectl rollout status deployment/helixone-data-service -n helixone --timeout=600s

# Run database migrations
echo "üóÉÔ∏è  Running database migrations"
kubectl run migration-job-$(date +%s) \
    --image="$ECR_REGISTRY/helixone/api:latest" \
    --restart=Never \
    --env="DATABASE_URL=$DATABASE_URL" \
    --command -- python -m alembic upgrade head

# Run smoke tests
echo "üß™ Running smoke tests"
sleep 30

# Test API health
kubectl run smoke-test-api-$(date +%s) \
    --image=curlimages/curl:8.1.0 \
    --restart=Never \
    --rm -i --tty \
    --command -- curl -f http://helixone-api-service:8000/health

# Test frontend health
kubectl run smoke-test-frontend-$(date +%s) \
    --image=curlimages/curl:8.1.0 \
    --restart=Never \
    --rm -i --tty \
    --command -- curl -f http://helixone-frontend-service:3000/health

echo "‚úÖ HelixOne deployment completed successfully!"
echo "üåê Application URL: https://helixone.com"
echo "üìä Monitoring: https://helixone.com/grafana"
echo "üìã Status: kubectl get pods -n helixone"

---
# scripts/rollback.sh
#!/bin/bash
set -euo pipefail

# HelixOne Rollback Script
# Usage: ./scripts/rollback.sh [revision_number]

REVISION=${1:-1}
ENVIRONMENT=${2:-production}

echo "üîÑ Rolling back HelixOne to revision $REVISION"

# Update kubeconfig
aws eks update-kubeconfig --region "${AWS_REGION:-us-west-2}" --name "helixone-$ENVIRONMENT"

# Rollback deployments
echo "‚è™ Rolling back API deployment"
kubectl rollout undo deployment/helixone-api -n helixone --to-revision="$REVISION"

echo "‚è™ Rolling back frontend deployment"
kubectl rollout undo deployment/helixone-frontend -n helixone --to-revision="$REVISION"

echo "‚è™ Rolling back data service deployment"
kubectl rollout undo deployment/helixone-data-service -n helixone --to-revision="$REVISION"

# Wait for rollback to complete
echo "‚è≥ Waiting for rollback to complete"
kubectl rollout status deployment/helixone-api -n helixone --timeout=600s
kubectl rollout status deployment/helixone-frontend -n helixone --timeout=600s
kubectl rollout status deployment/helixone-data-service -n helixone --timeout=600s

echo "‚úÖ Rollback completed successfully!"

# =============================================================================
# DISASTER RECOVERY SCRIPTS
# =============================================================================

---
# scripts/backup.sh
#!/bin/bash
set -euo pipefail

# HelixOne Backup Script
TIMESTAMP=$(date +%Y%m%d_%H%M%S)
BACKUP_BUCKET=${BACKUP_BUCKET:-helixone-backups-production}

echo "üíæ Starting HelixOne backup - $TIMESTAMP"

# Database backup
echo "üóÉÔ∏è  Creating database backup"
kubectl run db-backup-$TIMESTAMP \
    --image=postgres:15 \
    --restart=Never \
    --env="PGPASSWORD=$DB_PASSWORD" \
    --command -- pg_dump \
    -h "$DB_HOST" \
    -U "$DB_USER" \
    -d "$DB_NAME" \
    -f "/tmp/helixone-db-backup-$TIMESTAMP.sql"

# Copy backup to S3
kubectl cp db-backup-$TIMESTAMP:/tmp/helixone-db-backup-$TIMESTAMP.sql ./helixone-db-backup-$TIMESTAMP.sql
aws s3 cp "./helixone-db-backup-$TIMESTAMP.sql" "s3://$BACKUP_BUCKET/database/helixone-db-backup-$TIMESTAMP.sql"
rm "./helixone-db-backup-$TIMESTAMP.sql"

# Cleanup backup pod
kubectl delete pod db-backup-$TIMESTAMP

# Kubernetes configuration backup
echo "‚öôÔ∏è  Backing up Kubernetes configurations"
kubectl get all -n helixone -o yaml > "helixone-k8s-backup-$TIMESTAMP.yaml"
aws s3 cp "helixone-k8s-backup-$TIMESTAMP.yaml" "s3://$BACKUP_BUCKET/kubernetes/helixone-k8s-backup-$TIMESTAMP.yaml"
rm "helixone-k8s-backup-$TIMESTAMP.yaml"

# Secrets backup (encrypted)
echo "üîê Backing up secrets"
kubectl get secrets -n helixone -o yaml > "helixone-secrets-backup-$TIMESTAMP.yaml"
gpg --symmetric --cipher-algo AES256 --compress-algo 1 --s2k-mode 3 \
    --s2k-digest-algo SHA512 --s2k-count 65536 \
    --force-mdc --passphrase "$BACKUP_ENCRYPTION_KEY" \
    "helixone-secrets-backup-$TIMESTAMP.yaml"
aws s3 cp "helixone-secrets-backup-$TIMESTAMP.yaml.gpg" "s3://$BACKUP_BUCKET/secrets/helixone-secrets-backup-$TIMESTAMP.yaml.gpg"
rm "helixone-secrets-backup-$TIMESTAMP.yaml" "helixone-secrets-backup-$TIMESTAMP.yaml.gpg"

echo "‚úÖ Backup completed successfully!"
echo "üìÅ Backup location: s3://$BACKUP_BUCKET/"

---
# scripts/restore.sh
#!/bin/bash
set -euo pipefail

# HelixOne Restore Script
# Usage: ./scripts/restore.sh <backup_timestamp>

BACKUP_TIMESTAMP=${1:?Please provide backup timestamp (YYYYMMDD_HHMMSS)}
BACKUP_BUCKET=${BACKUP_BUCKET:-helixone-backups-production}

echo "üîÑ Restoring HelixOne from backup: $BACKUP_TIMESTAMP"

# Restore database
echo "üóÉÔ∏è  Restoring database"
aws s3 cp "s3://$BACKUP_BUCKET/database/helixone-db-backup-$BACKUP_TIMESTAMP.sql" "./helixone-db-backup-$BACKUP_TIMESTAMP.sql"

kubectl run db-restore-$BACKUP_TIMESTAMP \
    --image=postgres:15 \
    --restart=Never \
    --env="PGPASSWORD=$DB_PASSWORD" \
    --command -- psql \
    -h "$DB_HOST" \
    -U "$DB_USER" \
    -d "$DB_NAME" \
    -f "/tmp/helixone-db-backup-$BACKUP_TIMESTAMP.sql"

# Cleanup
kubectl delete pod db-restore-$BACKUP_TIMESTAMP
rm "./helixone-db-backup-$BACKUP_TIMESTAMP.sql"

echo "‚úÖ Database restore completed successfully!"

# =============================================================================
# PERFORMANCE TESTING
# =============================================================================

---
# tests/load-test.yaml
apiVersion: v1
kind: ConfigMap
metadata:
  name: load-test-script
  namespace: helixone
data:
  load-test.js: |
    import http from 'k6/http';
    import { check, sleep } from 'k6';
    import { Rate } from 'k6/metrics';

    export let errorRate = new Rate('errors');

    export let options = {
      stages: [
        { duration: '2m', target: 100 }, // Ramp up
        { duration: '5m', target: 100 }, // Stay at 100 users
        { duration: '2m', target: 200 }, // Ramp up to 200 users
        { duration: '5m', target: 200 }, // Stay at 200 users
        { duration: '2m', target: 0 },   // Ramp down
      ],
      thresholds: {
        http_req_duration: ['p(95)<2000'], // 95% of requests under 2s
        http_req_failed: ['rate<0.1'],     // Error rate under 10%
      },
    };

    const BASE_URL = 'https://api.helixone.com';

    export function setup() {
      // Login and get token
      let loginRes = http.post(`${BASE_URL}/auth/login`, {
        email: 'loadtest@helixone.com',
        password: 'LoadTest123!',
      });
      
      return { token: loginRes.json('access_token') };
    }

    export default function(data) {
      let headers = {
        'Authorization': `Bearer ${data.token}`,
        'Content-Type': 'application/json',
      };

      // Test health endpoint
      let healthRes = http.get(`${BASE_URL}/health`);
      check(healthRes, {
        'health status is 200': (r) => r.status === 200,
      }) || errorRate.add(1);

      // Test market data endpoint
      let marketRes = http.post(`${BASE_URL}/api/v2/market/data`, 
        JSON.stringify({
          symbols: ['AAPL', 'MSFT', 'GOOGL'],
          include_indicators: true,
        }), 
        { headers }
      );
      
      check(marketRes, {
        'market data status is 200': (r) => r.status === 200,
        'market data response time < 2000ms': (r) => r.timings.duration < 2000,
      }) || errorRate.add(1);

      // Test subscription endpoint
      let subRes = http.get(`${BASE_URL}/api/subscription/current`, { headers });
      check(subRes, {
        'subscription status is 200': (r) => r.status === 200,
      }) || errorRate.add(1);

      sleep(1);
    }

---
# tests/run-load-test.sh
#!/bin/bash
set -euo pipefail

echo "üß™ Running HelixOne load tests"

# Create test user if not exists
kubectl run create-test-user \
    --image=curlimages/curl:8.1.0 \
    --restart=Never \
    --rm -i --tty \
    --command -- curl -X POST https://api.helixone.com/auth/register \
    -H "Content-Type: application/json" \
    -d '{
      "email": "loadtest@helixone.com",
      "password": "LoadTest123!",
      "first_name": "Load",
      "last_name": "Test"
    }'

# Run load test
kubectl run load-test \
    --image=grafana/k6:latest \
    --restart=Never \
    --rm -i --tty \
    --overrides='{
      "spec": {
        "containers": [{
          "name": "k6",
          "image": "grafana/k6:latest",
          "command": ["k6", "run", "/scripts/load-test.js"],
          "volumeMounts": [{
            "name": "test-script",
            "mountPath": "/scripts"
          }]
        }],
        "volumes": [{
          "name": "test-script",
          "configMap": {
            "name": "load-test-script"
          }
        }]
      }
    }'

echo "‚úÖ Load test completed!"

# =============================================================================
# ENVIRONMENT CONFIGURATION FILES
# =============================================================================

---
# terraform/production.tfvars
aws_region = "us-west-2"
environment = "production"
domain_name = "helixone.com"

# Database configuration
db_password = "CHANGE-THIS-IN-PRODUCTION"
jwt_secret = "CHANGE-THIS-JWT-SECRET-IN-PRODUCTION"

# Scaling configuration
eks_node_desired_size = 5
eks_node_max_size = 20
eks_node_min_size = 3

# Monitoring
enable_enhanced_monitoring = true
log_retention_days = 90

---
# .env.production.template
# Copy to .env.production and fill in actual values

# AWS Configuration
AWS_REGION=us-west-2
AWS_ACCOUNT_ID=123456789012

# Database
DATABASE_URL=postgresql://helixone_user:password@helixone-db.region.rds.amazonaws.com:5432/helixone
REDIS_URL=redis://helixone-redis.cache.amazonaws.com:6379

# JWT
JWT_SECRET=your-super-secure-jwt-secret-256-bit

# Stripe
STRIPE_SECRET_KEY=sk_live_...
STRIPE_PUBLISHABLE_KEY=pk_live_...
STRIPE_WEBHOOK_SECRET=whsec_...

# External APIs
ALPHA_VANTAGE_API_KEY=your_alpha_vantage_key
NEWS_API_KEY=your_news_api_key
FINNHUB_API_KEY=your_finnhub_key

# Email
SMTP_SERVER=smtp.gmail.com
SMTP_PORT=587
SMTP_USERNAME=noreply@helixone.com
SMTP_PASSWORD=your_email_password
FROM_EMAIL=noreply@helixone.com

# Monitoring
GRAFANA_ADMIN_PASSWORD=secure_grafana_password
SLACK_WEBHOOK_URL=https://hooks.slack.com/...

# Backup
BACKUP_BUCKET=helixone-backups-production
BACKUP_ENCRYPTION_KEY=your_backup_encryption_key

# =============================================================================
# SECURITY HARDENING
# =============================================================================

---
# security/network-policies.yaml
apiVersion: networking.k8s.io/v1
kind: NetworkPolicy
metadata:
  name: helixone-network-policy
  namespace: helixone
spec:
  podSelector: {}
  policyTypes:
  - Ingress
  - Egress
  ingress:
  - from:
    - namespaceSelector:
        matchLabels:
          name: ingress-nginx
    - podSelector:
        matchLabels:
          app.kubernetes.io/name: ingress-nginx
  - from:
    - podSelector:
        matchLabels:
          app: helixone-api
    - podSelector:
        matchLabels:
          app: helixone-frontend
    - podSelector:
        matchLabels:
          app: helixone-data-service
    ports:
    - protocol: TCP
      port: 8000
    - protocol: TCP
      port: 3000
  egress:
  # Allow DNS
  - to: []
    ports:
    - protocol: TCP
      port: 53
    - protocol: UDP
      port: 53
  # Allow HTTPS
  - to: []
    ports:
    - protocol: TCP
      port: 443
  # Allow HTTP
  - to: []
    ports:
    - protocol: TCP
      port: 80
  # Allow database
  - to: []
    ports:
    - protocol: TCP
      port: 5432
  # Allow Redis
  - to: []
    ports:
    - protocol: TCP
      port: 6379

---
# security/pod-security-standards.yaml
apiVersion: v1
kind: Namespace
metadata:
  name: helixone
  labels:
    pod-security.kubernetes.io/enforce: restricted
    pod-security.kubernetes.io/audit: restricted
    pod-security.kubernetes.io/warn: restricted

---
# security/falco-rules.yaml
apiVersion: v1
kind: ConfigMap
metadata:
  name: helixone-falco-rules
  namespace: falco
data:
  helixone_rules.yaml: |
    - rule: Unauthorized API Access
      desc: Detect unauthorized access to HelixOne API
      condition: >
        k8s_audit and
        ka.verb in (create, update, delete) and
        ka.uri.path startswith /api and
        not ka.user.name in (helixone-api, system:serviceaccount:helixone:helixone-api)
      output: >
        Unauthorized API access
        (user=%ka.user.name verb=%ka.verb uri=%ka.uri.path
        resp=%ka.response_code reason=%ka.response_reason)
      priority: WARNING

    - rule: Sensitive Data Access
      desc: Detect access to sensitive HelixOne data
      condition: >
        spawned_process and
        proc.name in (pg_dump, redis-cli, kubectl) and
        container.name in (helixone-api, helixone-data-service)
      output: >
        Sensitive data access detected
        (command=%proc.cmdline container=%container.name image=%container.image)
      priority: WARNING

---
# security/security-scan.sh
#!/bin/bash
set -euo pipefail

echo "üîí Running security scans for HelixOne"

# Container image vulnerability scan
echo "üîç Scanning container images for vulnerabilities"
ECR_REGISTRY=$(aws sts get-caller-identity --query Account --output text).dkr.ecr.${AWS_REGION:-us-west-2}.amazonaws.com

services=("api" "frontend" "data-service")
for service in "${services[@]}"; do
    echo "Scanning $service image..."
    trivy image "$ECR_REGISTRY/helixone/$service:latest" \
        --severity HIGH,CRITICAL \
        --format table \
        --exit-code 1
done

# Kubernetes configuration scan
echo "üîç Scanning Kubernetes configurations"
kubectl get pods -n helixone -o yaml | \
    trivy config - \
    --severity HIGH,CRITICAL \
    --format table

# Network policy validation
echo "üîç Validating network policies"
kubectl describe networkpolicy helixone-network-policy -n helixone

# RBAC validation
echo "üîç Validating RBAC permissions"
kubectl auth can-i --list --as=system:serviceaccount:helixone:helixone-api -n helixone

echo "‚úÖ Security scan completed!"

# =============================================================================
# COST OPTIMIZATION
# =============================================================================

---
# cost-optimization/vertical-pod-autoscaler.yaml
apiVersion: autoscaling.k8s.io/v1
kind: VerticalPodAutoscaler
metadata:
  name: helixone-api-vpa
  namespace: helixone
spec:
  targetRef:
    apiVersion: apps/v1
    kind: Deployment
    name: helixone-api
  updatePolicy:
    updateMode: "Auto"
  resourcePolicy:
    containerPolicies:
    - containerName: api
      minAllowed:
        cpu: 250m
        memory: 256Mi
      maxAllowed:
        cpu: 2000m
        memory: 4Gi

---
# cost-optimization/cluster-autoscaler.yaml
apiVersion: v1
kind: ConfigMap
metadata:
  name: cluster-autoscaler-status
  namespace: kube-system
data:
  nodes.max: "20"
  nodes.min: "3"
  scale-down-delay-after-add: "10m"
  scale-down-unneeded-time: "10m"

---
# cost-optimization/spot-instances.yaml
apiVersion: v1
kind: ConfigMap
metadata:
  name: spot-instance-config
  namespace: kube-system
data:
  spot-interruption-handler.yaml: |
    apiVersion: apps/v1
    kind: DaemonSet
    metadata:
      name: aws-node-termination-handler
      namespace: kube-system
    spec:
      selector:
        matchLabels:
          app: aws-node-termination-handler
      template:
        metadata:
          labels:
            app: aws-node-termination-handler
        spec:
          containers:
          - name: aws-node-termination-handler
            image: public.ecr.aws/aws-ec2/aws-node-termination-handler:v1.19.0
            env:
            - name: NODE_NAME
              valueFrom:
                fieldRef:
                  fieldPath: spec.nodeName
            - name: POD_NAME
              valueFrom:
                fieldRef:
                  fieldPath: metadata.name
            - name: NAMESPACE
              valueFrom:
                fieldRef:
                  fieldPath: metadata.namespace
            - name: SPOT_INTERRUPTION_HANDLER
              value: "true"
            - name: SCHEDULED_EVENT_HANDLER
              value: "true"

# =============================================================================
# FINAL INTEGRATION SCRIPT
# =============================================================================

---
# scripts/complete-setup.sh
#!/bin/bash
set -euo pipefail

echo "üöÄ HelixOne Complete Production Setup"
echo "======================================"

# Color codes for output
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
NC='\033[0m' # No Color

# Function to print colored output
print_status() {
    echo -e "${GREEN}[INFO]${NC} $1"
}

print_warning() {
    echo -e "${YELLOW}[WARN]${NC} $1"
}

print_error() {
    echo -e "${RED}[ERROR]${NC} $1"
}

# Check if running as root
if [[ $EUID -eq 0 ]]; then
   print_error "This script should not be run as root"
   exit 1
fi

# Check prerequisites
print_status "Checking prerequisites..."
commands=("aws" "kubectl" "helm" "terraform" "docker")
for cmd in "${commands[@]}"; do
    if ! command -v "$cmd" &> /dev/null; then
        print_error "$cmd is required but not installed"
        exit 1
    fi
done

# AWS credentials check
if ! aws sts get-caller-identity &> /dev/null; then
    print_error "AWS credentials not configured"
    exit 1
fi

# Set default environment
ENVIRONMENT=${1:-production}
print_status "Deploying to $ENVIRONMENT environment"

# Load environment variables
if [ ! -f ".env.$ENVIRONMENT" ]; then
    print_error "Environment file .env.$ENVIRONMENT not found"
    print_status "Please copy .env.$ENVIRONMENT.template to .env.$ENVIRONMENT and configure"
    exit 1
fi

set -o allexport
source ".env.$ENVIRONMENT"
set +o allexport

print_status "Environment variables loaded"

# Step 1: Deploy Infrastructure
print_status "Step 1: Deploying AWS infrastructure with Terraform..."
cd terraform
terraform init -backend-config="bucket=helixone-terraform-state-${AWS_ACCOUNT_ID}"
terraform plan -var-file="$ENVIRONMENT.tfvars" -out="$ENVIRONMENT.plan"

echo ""
read -p "$(echo -e ${YELLOW}Review the Terraform plan above. Continue? [y/N]:${NC} )" -n 1 -r
echo
if [[ ! $REPLY =~ ^[Yy]$ ]]; then
    print_error "Infrastructure deployment cancelled"
    exit 1
fi

terraform apply "$ENVIRONMENT.plan"
print_status "Infrastructure deployed successfully"
cd ..

# Step 2: Configure kubectl
print_status "Step 2: Configuring kubectl..."
aws eks update-kubeconfig --region "$AWS_REGION" --name "helixone-$ENVIRONMENT"

# Step 3: Install cluster components
print_status "Step 3: Installing cluster components..."

# External Secrets Operator
kubectl create namespace external-secrets-system --dry-run=client -o yaml | kubectl apply -f -
helm repo add external-secrets https://charts.external-secrets.io
helm repo update
helm upgrade --install external-secrets external-secrets/external-secrets \
    --namespace external-secrets-system \
    --wait --timeout=10m

# AWS Load Balancer Controller
helm repo add eks https://aws.github.io/eks-charts
helm upgrade --install aws-load-balancer-controller eks/aws-load-balancer-controller \
    --namespace kube-system \
    --set clusterName="helixone-$ENVIRONMENT" \
    --set serviceAccount.create=false \
    --set serviceAccount.name=aws-load-balancer-controller \
    --wait --timeout=10m

# Cluster Autoscaler
kubectl apply -f cost-optimization/cluster-autoscaler.yaml

print_status "Cluster components installed"

# Step 4: Install monitoring
print_status "Step 4: Installing monitoring stack..."
kubectl create namespace monitoring --dry-run=client -o yaml | kubectl apply -f -

# Prometheus and Grafana
helm repo add prometheus-community https://prometheus-community.github.io/helm-charts
helm repo add grafana https://grafana.github.io/helm-charts
helm repo update

helm upgrade --install prometheus-stack prometheus-community/kube-prometheus-stack \
    --namespace monitoring \
    --values monitoring/prometheus-values.yaml \
    --wait --timeout=15m

# Loki for logs
helm upgrade --install loki grafana/loki-stack \
    --namespace monitoring \
    --values monitoring/loki-values.yaml \
    --wait --timeout=10m

# Falco for runtime security
helm repo add falcosecurity https://falcosecurity.github.io/charts
helm upgrade --install falco falcosecurity/falco \
    --namespace falco --create-namespace \
    --wait --timeout=10m

print_status "Monitoring stack installed"

# Step 5: Deploy application
print_status "Step 5: Building and deploying HelixOne application..."

# Build and push images
ECR_REGISTRY="${AWS_ACCOUNT_ID}.dkr.ecr.${AWS_REGION}.amazonaws.com"
aws ecr get-login-password --region "$AWS_REGION" | docker login --username AWS --password-stdin "$ECR_REGISTRY"

services=("api" "frontend" "data-service")
for service in "${services[@]}"; do
    print_status "Building $service image..."
    docker build -f "docker/$service/Dockerfile" -t "helixone/$service:latest" .
    docker tag "helixone/$service:latest" "$ECR_REGISTRY/helixone/$service:latest"
    docker push "$ECR_REGISTRY/helixone/$service:latest"
done

# Create application namespace
kubectl create namespace helixone --dry-run=client -o yaml | kubectl apply -f -

# Apply security policies
kubectl apply -f security/pod-security-standards.yaml
kubectl apply -f security/network-policies.yaml

# Deploy application manifests
export ECR_REGISTRY
export IMAGE_TAG=latest
export API_SERVICE_ROLE_ARN

print_status "Deploying Kubernetes manifests..."
for manifest in kubernetes/*.yaml; do
    envsubst < "$manifest" | kubectl apply -f -
done

# Wait for deployments
print_status "Waiting for deployments to be ready..."
kubectl rollout status deployment/helixone-api -n helixone --timeout=600s
kubectl rollout status deployment/helixone-frontend -n helixone --timeout=600s
kubectl rollout status deployment/helixone-data-service -n helixone --timeout=600s

# Step 6: Run database migrations
print_status "Step 6: Running database migrations..."
kubectl run migration-job-$(date +%s) \
    --image="$ECR_REGISTRY/helixone/api:latest" \
    --restart=Never \
    --env="DATABASE_URL=$DATABASE_URL" \
    --command -- python -m alembic upgrade head

# Step 7: Run tests
print_status "Step 7: Running smoke tests..."
sleep 30

# Health checks
kubectl run smoke-test-$(date +%s) \
    --image=curlimages/curl:8.1.0 \
    --restart=Never \
    --rm -i --tty \
    --timeout=60s \
    --command -- sh -c "
        echo 'Testing API health...'
        curl -f http://helixone-api-service:8000/health
        echo 'Testing frontend health...'
        curl -f http://helixone-frontend-service:3000/health
        echo 'All health checks passed!'
    "

# Step 8: Configure monitoring alerts
print_status "Step 8: Configuring monitoring and alerts..."
kubectl apply -f monitoring/alerts.yaml
kubectl apply -f monitoring/helixone-servicemonitor.yaml

# Step 9: Security hardening
print_status "Step 9: Applying security hardening..."
./security/security-scan.sh

# Step 10: Cost optimization
print_status "Step 10: Configuring cost optimization..."
kubectl apply -f cost-optimization/vertical-pod-autoscaler.yaml
kubectl apply -f cost-optimization/spot-instances.yaml

# Final status check
print_status "Final system status check..."
echo ""
echo "=== HelixOne System Status ==="
echo "Namespace: helixone"
kubectl get pods -n helixone
echo ""
echo "Services:"
kubectl get svc -n helixone
echo ""
echo "Ingress:"
kubectl get ingress -n helixone
echo ""

# Get important URLs
ALB_DNS=$(kubectl get ingress helixone-ingress -n helixone -o jsonpath='{.status.loadBalancer.ingress[0].hostname}' 2>/dev/null || echo "Not available")
GRAFANA_URL="https://helixone.com/grafana"

echo "=== HelixOne Deployment Complete! ==="
echo ""
print_status "‚úÖ Infrastructure: Deployed"
print_status "‚úÖ Application: Running"
print_status "‚úÖ Monitoring: Active"
print_status "‚úÖ Security: Hardened"
print_status "‚úÖ Cost Optimization: Configured"
echo ""
echo "üåê Application URL: https://helixone.com"
echo "üìä Monitoring: $GRAFANA_URL"
echo "‚öñÔ∏è  Load Balancer: $ALB_DNS"
echo ""
echo "üìã Next Steps:"
echo "1. Configure DNS: Point helixone.com to the load balancer"
echo "2. Test all functionality: Registration, payment, API access"
echo "3. Set up monitoring alerts: Configure Slack/email notifications"
echo "4. Schedule backups: Set up automated daily backups"
echo "5. Performance testing: Run load tests to validate scaling"
echo ""
print_status "üéâ HelixOne is ready for production traffic!"

exit 0# =============================================================================
# CI/CD PIPELINE - GITHUB ACTIONS
# =============================================================================

# .github/workflows/deploy-production.yml
name: Deploy to Production

on:
  push:
    branches: [ main ]
    tags: [ 'v*' ]
  pull_request:
    branches: [ main ]

env:
  AWS_REGION: us-west-2
  ECR_REGISTRY: ${{ secrets.AWS_ACCOUNT_ID }}.dkr.ecr.us-west-2.amazonaws.com
  EKS_CLUSTER_NAME: helixone-production

jobs:
  test:
    name: Run
